import sys, os, subprocess
from enum import Enum

expected_args = 1

# clean_crashes = False
# if '--clean-crashes' in sys.argv:
# 	clean_crashes = True
# 	expected_args+=1

# count_funcs = False
# if '--count-funcs' in sys.argv:
# 	count_funcs = True
# 	expected_args+=1

# if len(sys.argv) == expected_args:
# 	print("Usage: python3 autoUpdater.py <OPTIONAL ARGS> (path to C file)")
# 	exit(1)

srcRepoPath = sys.argv[1].split("src")[0]

def getFileName(_file):
	return _file.split('/')[-1].split('.')[0]

def getNewFunc(_fileName):
	proc = subprocess.Popen("./mips_to_c/mips_to_c.py --no-andor "+_fileName+" "+getFileName(_fileName),
		shell=True,
		stdout=subprocess.PIPE)
	return proc.communicate()

def getGlobalAsmFile(_file):
	return _file.replace("\"", " ").split()[1]

def getFuncName(_str):
	temp = _str.replace("("," ").replace(":"," ").replace("*"," ").replace(")"," ").split()
	return ''.join([i for i in temp if "func_" in i])

process = subprocess.Popen('git ls-files -s mips_to_c/', shell=True,
                           stdout=subprocess.PIPE)
mips_to_c_version = process.communicate()
mips_to_c_version = mips_to_c_version[0].decode("ascii").split()[1]

# file bounds constants
START = 0
END = 1


funcBounds = {}
global_asm_lookup = {} # just in case

# Pass 1: populate data structures

fileName = os.getcwd()+"/tmp/"+getFileName(sys.argv[-1])+".c"
inFile = open(sys.argv[-1], "r")
fileBuffer = inFile.readlines()
inFile.close()
inFile = open(sys.argv[-1], "r")

ifdef_line = 1
global_asm_file = 1
end_line = 1

funcName = ""

lineNum = 0

inFunc = 0

for line in inFile:
	if "//" in line:
		lineNum+=1
		continue
	if "#ifdef" in line:
		inFunc = 1
		ifdef_line = lineNum
	if "func_" in line and (lineNum - ifdef_line == 2):
		funcName = getFuncName(line)
	if "GLOBAL_ASM" in line:
		global_asm_file = getGlobalAsmFile(line)
	if "#endif" in line and inFunc == 1:
		inFunc = 0
		funcBounds[funcName] = [ifdef_line, lineNum]
		global_asm_lookup[funcName] = global_asm_file
	lineNum+=1

print(funcBounds)
print(global_asm_lookup)


toDel = []
# Pass 2: filter out functions that are up to date
for sym in funcBounds:
	temp = funcBounds[sym]
	if "mips_to_c commit" in fileBuffer[temp[START]+1]:
		commit = fileBuffer[temp[START]+1].split()[-1]
		if commit == mips_to_c_version:
			toDel.append(sym)
			del global_asm_lookup[sym]
for i in toDel:
	del funcBounds[i]

print(funcBounds)
print(global_asm_lookup)

# Pass 3: Write the new file and place a new function
startLine = 0
outFile = open("tmp.c",'w+')
for sym in funcBounds:
	tmp = funcBounds[sym]
	outFile.write(''.join(fileBuffer[startLine:tmp[START]]))
	startLine = tmp[END]
	outFile.write("#ifdef MIPS_TO_C\n")
	outFile.write("// generated by mips_to_c commit "+mips_to_c_version+"\n")
	x = getNewFunc(srcRepoPath+global_asm_lookup[sym])[0].decode('ascii')
	outFile.write(x)
	outFile.write("#else\n")
	outFile.write("GLOBAL_ASM(\""+global_asm_lookup[sym]+"\")\n")

# flush
outFile.write(''.join(fileBuffer[startLine:]))

outFile.close()